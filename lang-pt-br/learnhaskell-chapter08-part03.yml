title: Type parameters

text:  Um construtor de valor pode receber alguns valores de parâmetro e então produzir um novo valor. Por exemplo, o construtor [code]Car[/code] recebe três valores e produz o valor car. De maneira similar, <em>type constructors</em> pode receber tipos como parâmetros para produzir um novo tipo. Isso pode soar um pouco estranho inicialmente, porém não é nada complicado. Se você é familiar com templates em C++, você vai perceber algumas semelhanças. Para obter uma imagem clara de como type parameters funcionam em ação, vamos dar uma olhada em como um tipo que já conhecemos é implementado.



A letra [code]a[/code] aqui é um type parameter. E, porque há um type parameter envolvido, nós chamamos  [code]Maybe[/code] como um construtor de tipo. Dependendo do que nós queremos que esse tipo de dado guarde quando ele não for  [code]Nothing[/code], esse construtor de tipo poderá acabar produzindo tipos como [code]Maybe Int[/code], [code]Maybe Car[/code], [code]Maybe String[/code], etc. Nenhum valor pode ter apenas o tipo [code]Maybe[/code], devido ao fato de que ele não é exatamente um tipo, ele é um construtor de tipos. A fim de que ele seja um tipo real de forma que um valor possa fazer parte dele, ele precisa que todos seus types parameters sejam preenchidos.

Logo, se nós passarmos [code]Char[/code] como sendo o type parameter de [code]Maybe[/code], nós temos um tipo de [code]Maybe Char[/code]. O valor [code]Just 'a'[/code] tem o tipo de [code]Maybe Char[/code], por exemplo.

Você pode não saber, porém nós usamos um tipo que tem um type parameter antes de usarmos [code]Maybe[/code]. Esse tipo é o tipo list. Embora haja um pouco de açúcar sintático em jogo, o tipo list recebe um parametro e produz um tipo concreto. Os valores podem ter o tipo  [code][Int][/code], ou o tipo [code][Char][/code], ou o tipo [code][[String]][/code], mas você não pode ter um valor cujo o tipo seja [code][][/code].

Vamos brincar um pouco com o tipo [code]Maybe[/code].



Os type parameters são úteis pois nós podemos criar diferentes tipos com eles, dependendo da espécie de tipos nós queremos que contenha nos nossos dados. Quando nós fazemos [code]:t Just "Haha"[/code], o motor de inferência de tipos identifica-os como sendo do tipo [code]Maybe [Char][/code], devido ao fato de que o [code]a[/code] no [code]Just a[/code] é uma string, então o code]a[/code] no [code]Maybe a[/code] também deve ser uma string.





Notice that the type of [code]Nothing[/code] is [code]Maybe a[/code]. Its type is polymorphic. If some function requires a [code]Maybe Int[/code] as a parameter, we can give it a [code]Nothing[/code], because a [code]Nothing[/code] doesn't contain a value anyway and so it doesn't matter. The [code]Maybe a[/code] type can act like a [code]Maybe Int[/code] if it has to, just like [code]5[/code] can act like an [code]Int[/code] or a [code]Double[/code]. Similarly, the type of the empty list is [code][a][/code]. An empty list can act like a list of anything. That's why we can do [code][1,2,3] ++ [][/code] and [code]["ha","ha","ha"] ++ [][/code].

Using type parameters is very beneficial, but only when using them makes sense. Usually we use them when our data type would work regardless of the type of the value it then holds inside it, like with our [code]Maybe a[/code] type. If our type acts as some kind of box, it's good to use them. We could change our [code]Car[/code] data type from this:



To this:



But would we really benefit? The answer is: probably no, because we'd just end up defining functions that only work on the [code]Car String String Int[/code] type. For instance, given our first definition of [code]Car[/code], we could make a function that displays the car's properties in a nice little text.




A cute little function! The type declaration is cute and it works nicely. Now what if [code]Car[/code] was [code]Car a b c[/code]?



We'd have to force this function to take a [code]Car[/code] type of [code](Show a) =&gt; Car String String a[/code]. You can see that the type signature is more complicated and the only benefit we'd actually get would be that we can use any type that's an instance of the [code]Show[/code] typeclass as the type for [code]c[/code].



In real life though, we'd end up using [code]Car String String Int[/code] most of the time and so it would seem that parameterizing the [code]Car[/code] type isn't really worth it. We usually use type parameters when the type that's contained inside the data type's various value constructors isn't really that important for the type to work. A list of stuff is a list of stuff and it doesn't matter what the type of that stuff is, it can still work. If we want to sum a list of numbers, we can specify later in the summing function that we specifically want a list of numbers. Same goes for [code]Maybe[/code]. [code]Maybe[/code] represents an option of either having nothing or having one of something. It doesn't matter what the type of that something is.

Another example of a parameterized type that we've already met is [code]Map k v[/code] from [code]Data.Map[/code]. The [code]k[/code] is the type of the keys in a map and the [code]v[/code] is the type of the values. This is a good example of where type parameters are very useful. Having maps parameterized enables us to have mappings from any type to any other type, as long as the type of the key is part of the [code]Ord[/code] typeclass. If we were defining a mapping type, we could add a typeclass constraint in the <i>data</i> declaration:




However, it's a very strong convention in Haskell to <em>never add typeclass constraints in data declarations. </em>Why? Well, because we don't benefit a lot, but we end up writing more class constraints, even when we don't need them. If we put or don't put the [code]Ord k[/code] constraint in the <i>data</i> declaration for [code]Map k v[/code], we're going to have to put the constraint into functions that assume the keys in a map can be ordered. But if we don't put the constraint in the data declaration, we don't have to put [code](Ord k) =&gt;[/code] in the type declarations of functions that don't care whether the keys can be ordered or not. An example of such a function is [code]toList[/code], that just takes a mapping and converts it to an associative list. Its type signature is [code]toList :: Map k a -&gt; [(k, a)][/code]. If [code]Map k v[/code] had a type constraint in its <i>data</i> declaration, the type for [code]toList[/code] would have to be [code]toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)][/code], even though the function doesn't do any comparing of keys by order.

So don't put type constraints into <i>data</i> declarations even if it seems to make sense, because you'll have to put them into the function type declarations either way.

Let's implement a 3D vector type and add some operations for it. We'll be using a parameterized type because even though it will usually contain numeric types, it will still support several of them.




[code]vplus[/code] is for adding two vectors together. Two vectors are added just by adding their corresponding components. [code]scalarMult[/code] is for the scalar product of two vectors and [code]vectMult[/code] is for multiplying a vector with a scalar. These functions can operate on types of [code]Vector Int[/code], [code]Vector Integer[/code], [code]Vector Float[/code], whatever, as long as the [code]a[/code] from [code]Vector a[/code] is from the [code]Num[/code] typeclass. Also, if you examine the type declaration for these functions, you'll see that they can operate only on vectors of the same type and the numbers involved must also be of the type that is contained in the vectors. Notice that we didn't put a [code]Num[/code] class constraint in the <i>data</i> declaration, because we'd have to repeat it in the functions anyway.

Once again, it's very important to distinguish between the type constructor and the value constructor. When declaring a data type, the part before the [code]=[/code] is the type constructor and the constructors after it (possibly separated by [code]|[/code]'s) are value constructors. Giving a function a type of [code]Vector t t t -&gt; Vector t t t -&gt; t[/code] would be wrong, because we have to put types in type declaration and the vector <em>type</em> constructor takes only one parameter, whereas the value constructor takes three. Let's play around with our vectors.
