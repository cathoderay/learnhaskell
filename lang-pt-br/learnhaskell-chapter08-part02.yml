title: Record syntax

text:  OK, nós precisamos criar um tipo de dado que descreve uma pessoa. A informação que queremos armazenar sobre esta pessoa é: nome, sobrenome, idade, altura, telefone e sorvete favorito. Não sei você, mas isto é tudo que eu sempre quis saber sobre uma pessoa. Vamos tentar!



O-key. O primeiro campo será o nome, o segundo será o sobrenome, o terceiro será a idade e assim por diante. Vamos fazer uma pessoa.



Isto é legal, apesar de ser muito legível. E se nós quisessemos criar uma função para pegar cada informação de uma pessoa? Uma função para pegar o nome de uma pessoa, uma função para pegar o sobrenome de uma pessoa, etc. Bem, precisamos definir estas funções desta forma.




Whew! I certainly did not enjoy writing that! Despite being very cumbersome and BORING to write, this method works.



There must be a better way, you say! Well no, there isn't, sorry.

Just kidding, there is. Hahaha! The makers of Haskell were very smart and anticipated this scenario. They included an alternative way to write data types. Here's how we could achieve the above functionality with record syntax.




So instead of just naming the field types one after another and separating them with spaces, we use curly brackets. First we write the name of the field, for instance, [code]firstName[/code] and then we write a double colon [code]::[/code] (also called Paamayim Nekudotayim, haha) and then we specify the type. The resulting data type is exactly the same. The main benefit of this is that it creates functions that lookup fields in the data type. By using record syntax to create this data type, Haskell automatically made these functions: [code]firstName[/code], [code]lastName[/code], [code]age[/code], [code]height[/code], [code]phoneNumber[/code] and [code]flavor[/code].




There's another benefit to using record syntax. When we derive [code]Show[/code] for the type, it displays it differently if we use record syntax to define and instantiate the type. Say we have a type that represents a car. We want to keep track of the company that made it, the model name and its year of production. Watch.



If we define it using record syntax, we can make a new car like this.



When making a new car, we don't have to necessarily put the fields in the proper order, as long as we list all of them. But if we don't use record syntax, we have to specify them in order.

Use record syntax when a constructor has several fields and it's not obvious which field is which. If we make a 3D vector data type by doing [code]data Vector = Vector Int Int Int[/code], it's pretty obvious that the fields are the components of a vector. However, in our [code]Person[/code] and [code]Car[/code] types, it wasn't so obvious and we greatly benefited from using record syntax.
